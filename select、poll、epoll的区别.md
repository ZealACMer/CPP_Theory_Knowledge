`select`, `poll`, `epoll` 都是I/O多路复用机制，它们允许程序监视多个文件描述符（file descriptors，FDs），以便知道是否有I/O可读取、可写入或有其他I/O事件发生。但是，这三种机制在实现和效率上有所不同。

### select

`select` 函数提供基本的I/O多路复用功能。使用一个`fd_set`数据结构，其中包含一系列要检查的FDs。`select`在调用时会阻塞，直至某个FDs发生了状态改变（可读、可写或错误）或发生超时。`select`调用返回后，程序需要遍历整个`fd_set`来找到状态更改的FDs。

#### `select`的限制:
1. **固定大小的FD集合**：`select`通常受限于FD_SETSIZE的大小限制，这个限制在不同系统中可能不同，但通常是1024。
2. **不够高效**：随着FDs数量的增加，需要遍历整个集合来检查状态，会导致性能问题。

### poll

`poll` 类似于`select`，但是使用`pollfd`结构数组，而非固定大小的集合。它提供了与`select`相似的功能，但是没有FD个数上的限制。

#### `poll`的改进：
1. **没有固定大小限制**：可以监视任意数量的FDs，不受`FD_SETSIZE`限制。
2. **易于使用新的FDs**：向数组中添加新的`pollfd`结构很简单，不需要改变现有结构。

但是，`poll`还是存在效率问题，因为即使有大量FDs，它也需要遍历整个列表来查找状态更改的FDs。

### epoll

`epoll`是Linux特有的I/O多路复用机制，它既解决了`select`固定大小的问题，也解决了`poll`需要遍历整个数组的问题。

#### `epoll`的优势：
1. **更高的效率**：`epoll`采用一种不同的技术，当FDs的状态改变时，它只会通知这些改变的FDs。这意味着即使监视数千个FDs，它也能高效地工作。
2. **优化的数据结构**：`epoll`使用一个内核事件表，程序在进入等待前告诉内核需要监视哪些FDs，然后只返回发生了状态改变的那些FDs。
3. **二种工作模式**：`epoll`可以工作在边缘触发（ET）和水平触发（LT）两种模式下。默认水平触发（和`select`/`poll`相似）意味着只要FDs状态符合条件就会持续通知。边缘触发意味着只在FDs状态从不符合条件变为符合条件时才会通知一次，这允许更高效的FDs状态管理。

`epoll`是最现代的I/O多路复用解决方案，对于大型服务器应用来说是最理想的选择。在处理大量并发连接时，`epoll`的性能优于`select`和`poll`。然而，`epoll`仅在Linux内核中可用；其他类Unix系统提供了类似的替代方案，如BSD的`kqueue`。
